<!DOCTYPE html>
<html >
<head>

    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google-site-verification" content="iPprDb-KWbQjQinbLCQXoHgtFcMpLVuZKqwkWiuC9hI" />
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript" >
		(function (d, w, c) {
			(w[c] = w[c] || []).push(function() {
				try {
					w.yaCounter51401461 = new Ya.Metrika2({
						id:51401461,
						clickmap:true,
						trackLinks:true,
						accurateTrackBounce:true
					});
				} catch(e) { }
			});

			var n = d.getElementsByTagName("script")[0],
				s = d.createElement("script"),
				f = function () { n.parentNode.insertBefore(s, n); };
			s.type = "text/javascript";
			s.async = true;
			s.src = "https://mc.yandex.ru/metrika/tag.js";

			if (w.opera == "[object Opera]") {
				d.addEventListener("DOMContentLoaded", f, false);
			} else { f(); }
		})(document, window, "yandex_metrika_callbacks2");
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/51401461" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <meta charset="utf-8" />
    <title>Перевод: Подробное руководство по flexbox</title>
    <link type="application/atom+xml" rel="alternate" href="https://handleman.github.io/feed.xml" title="Переводы, комиксы, разработка" />
    <!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Перевод: Подробное руководство по flexbox | Переводы, комиксы, разработка</title>
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Перевод: Подробное руководство по flexbox" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Простыми словами, flexbox layout (флексбокс) это набор CSS правил описывающий принцип, который помогает разработчику удобно располагать блоки относительно друг друга и эффективнее использовать свободное место между блоками на странице. Использование flexbox решает старую наболевшую проблему — центрирование блоков по вертикали при неизвестной высоте как самих блоков, так и подложки под ними. Основная идея, стоящая за flexbox, это: способность родительского контейнера менять высоту/ширину (и порядок) своих дочерних элементов, для наиболее эффективного использования доступного пространства (также для того, чтобы подстраиваться под разрешение всех видов устройств и размеров экранов). Короче говоря, родительский флекс-контейнер расширяет внутренние блоки чтобы занять свободное пространство или же сжимает их чтобы избежать наложения их друг на друга. Самое важное во flexbox, это то, что этот принцип не зависит от общего направления отрисовки страницы и других блоков (display: block, которые следуют друг за другом вертикально и display: inline, которые располагаются горизонтально друг от друга). Старый принцип (block,inline,inline-block) работает отлично, но для простых страниц. Современные сложные динамические интерфейсы требуют более эффективный подход. Терминология Потому как flexbox Это отдельный принцип расположения блоков, а не просто CSS свойство, помимо прочего, он включает в себя целый набор свойств. Некоторые из этих свойств предназначены для применения на родительском контейнере (flex container) тогда как другие — на дочерних (flex items). Если обычный метод верстки строится на порядке следования отрисовки страницы, flex использует свой принцип для выстраивания порядка следования дочернихблоков (flex-flow directions). Предлагаю взглянуть на изображение из спецификации и разобрать все термины по порядку. Общая схема flexbox layout В общих чертах, можно сказать, что блоки внутри родительского контейнера будут располагаться по главной оси (main axis) от начала (main-start) до конца оси (main-end) или же по перпендикулярной оси (cross axis) от начала (cross-start) до конца оси (cross-end). Термины на изображении main axis - главная ось по которой располагаются дочерние объекты. Кстати, совсем не обязательно это должна быть горизонтальная ось, это завсист от указанного вами flex-direction свойства (см.ниже). main-start | main-end - дочерние блоки располагаются от main-start и до main-end. Фактически начало и конец оси. main size - длина или ширина доступная для заполнения дочерними элементами вдоль главной оси. cross axis - ось, перпендикулярная главной оси. Направление перпендикулярной оси зависит от того, какую ось вы указали в качестве главной. cross-start | cross-end - начало и конец перпендикулярной оси, по которой будут располагаться дочерние элементы. cross size- длина или ширина доступная для заполнения дочерними элементами вдоль перпендикулярной оси. В итоге нас есть Родительский элемент (flex container), в котором расположены дочерние элементы (flex item) и набор правил для управления выводом этих элементов. Давайте последовательно разберем эти свойства. Свойства родительского элемента (flex container) display Это свойство определяет родительский контейнер, так же оно активирует контекст для всех дочерних элементов flex-direction Это свойство определяет главную ось и направление расположения блоков вдоль нее. В общих чертах flexbox располагает блоки либо по горизонтали (row) либо по вертикали (column) вдоль оси. row - (по умолчанию) слева на право (ltr) либо справа на лево (rtl); row-reverse - меняет порядок на противоположный; column - тоже самое что и row но для направления сверху в низ; column-reverse - меняет направление для вертикальной оси. flex-wrap Это свойство определяет порядок переноса элементов. По умолчанию все дочерние элементы стремятся уместиться на одной линии по направлению главной оси. nowrap - (используется по умолчанию) расположение блоков в одну строку; wrap - расположение в несколько линий (похоже на перенос по словам в письменной речи); wrap-reverse - расположение в несколько линий только в обратном направлении главной оси. flex-flow Это свойство является сокращением для комбинирования 2х свойств: flex-direction и flex-wrap. Оба этих свойства вместе определяют главную и перпендикулярную ось. По умолчанию используются значения row и nowrap соответсвенно. justify-content Это свойство определяет расположение блоков вдоль главной оси. Это свойство помогает распределить свободное место оставшееся после рендеринга дочерних элементов. Так же это дает некоторою возможность для разработчика управлять поведением элементов при переполнении родительского контейнера. flex-start - (по умолчанию) дочерние элементы группируются у стартовой лини (main-start на общей схеме) вдоль главной оси; flex-end - дочерние элементы группируются у конечной линии (main-end на общей схеме) вдоль главной оси; center - дочерние элементы центрированы по центру главной оси; space-between - первый элемент на стартовой лини (main-start на общей схеме), последний на конечной линии(main-end на общей схеме), а свободное пространство распределяется равномерно между оставшимися элементами; space-around - распределяет свободное место для всех дочерних элементов равномерно, но с учетом индивидуальных свойств отступов для дочерних элементов. align-items Это свойство определяет расположение дочерних элементов (flex items) относительно друг друга по перпендикулярной оси. Можно сказать что это свойство такое же как justify-content только для перпендикулярной оси. Чем то напоминает мне свойство vertical-align для inline-block элементов. flex-start - начальная граница перпендикулярной оси (cross-start на общей схеме); flex-end - конечная граница перпендикулярной оси (cross-end на общей схеме); center - дочерние объекты располагаются относительно центра перпендикулярной оси; baseline - элементы располагаются по базовой линии относительно друг друга; stretch - (по умолчанию) элементы вытягиваются вдоль перпендикулярной оси и занимают все пространство родительского блока. align-content Это свойство выравнивает линии внутри родительского контейнера вдоль перпендикулярной оси (cross-axis на общей схеме), аналогично тому как работает свойство justify-content только не для отдельного элемента а для всей строки (линии) элементов сразу. Это свойство не работает если элементы не переносятся на другую строку. flex-start - линии группируются у стартовой позиции перпендикулярной оси контейнера; flex-end - линии группируются у конечной позиции перпендикулярной оси; center - линии группируются по центру перпендикулярной оси; space-between - Первая линия элементов располагается у стартовой позиции оси а последняя у конечной. Линии между первой и последней распределяются равномерно между собой вдоль перпендикулярной оси; space-around - линии равномерно распределены относительно друг друга вдоль перпендикулярной оси с равным расстоянием между друг другом; stretch - линии равномерно расширяются чтобы занять все свободное пространство относительно перпендикулярной оси. Свойства дочерних объектов (flex items) order По умолчанию дочерние объекты расположены в поредяке следования по исходному коду. Это свойство позволяет контролировать порядок отображение объектов относительно друг друга. flex-grow Это свойство определяет способность отдельных элементов расширятся при необходимости. Свойство является по сути пропорцией относительно других элементов. Если всем элементам задать значение 1 для этого свойства, каждый элемент будет одинаковой ширины, если же одному из этих элементов задать 2, то этот элемент будет в 2 раза шире остальных. flex-shrink Это свойство определяет способность элемента к расширению, так же является пропорцией к остальным элементам. По умолчанию равно 1. flex-basis Это свойство определяет размер элемента по умолчанию, перед тем как произойдет распределение свободного пространства между остальными элементами. Если указано свойство main-size то тогда flex-basis будет равно css свойствам height или width этого элемнта, в зависимости от того какая ось и направление активны. flex Это свойство является комбинированным сокращением для свойств: flex-grow, flex-shrink и flex-basis. Второй и третий параметр ( flex-shrink и flex-basis) не обязательны. Значение этого свойства по умолчанию: 0 1 auto Рекомендуется использовать именно это свойство вместо использования отдельных flex-grow, flex-shrink и flex-basis. align-self Это свойство позволяет индивидуально выравнивать конкретный выбранный элемент относительно других. Имеет приоритет над общим свойством align-items. Вот собственно и все. Данная заметка является моим вольным переводом оригинальной статьи Криса Койера, Там вы можете уточнить информацию а так же найти примеры использования, таблицу поддержки flexbox в различных браузерах и т.д." />
<meta property="og:description" content="Простыми словами, flexbox layout (флексбокс) это набор CSS правил описывающий принцип, который помогает разработчику удобно располагать блоки относительно друг друга и эффективнее использовать свободное место между блоками на странице. Использование flexbox решает старую наболевшую проблему — центрирование блоков по вертикали при неизвестной высоте как самих блоков, так и подложки под ними. Основная идея, стоящая за flexbox, это: способность родительского контейнера менять высоту/ширину (и порядок) своих дочерних элементов, для наиболее эффективного использования доступного пространства (также для того, чтобы подстраиваться под разрешение всех видов устройств и размеров экранов). Короче говоря, родительский флекс-контейнер расширяет внутренние блоки чтобы занять свободное пространство или же сжимает их чтобы избежать наложения их друг на друга. Самое важное во flexbox, это то, что этот принцип не зависит от общего направления отрисовки страницы и других блоков (display: block, которые следуют друг за другом вертикально и display: inline, которые располагаются горизонтально друг от друга). Старый принцип (block,inline,inline-block) работает отлично, но для простых страниц. Современные сложные динамические интерфейсы требуют более эффективный подход. Терминология Потому как flexbox Это отдельный принцип расположения блоков, а не просто CSS свойство, помимо прочего, он включает в себя целый набор свойств. Некоторые из этих свойств предназначены для применения на родительском контейнере (flex container) тогда как другие — на дочерних (flex items). Если обычный метод верстки строится на порядке следования отрисовки страницы, flex использует свой принцип для выстраивания порядка следования дочернихблоков (flex-flow directions). Предлагаю взглянуть на изображение из спецификации и разобрать все термины по порядку. Общая схема flexbox layout В общих чертах, можно сказать, что блоки внутри родительского контейнера будут располагаться по главной оси (main axis) от начала (main-start) до конца оси (main-end) или же по перпендикулярной оси (cross axis) от начала (cross-start) до конца оси (cross-end). Термины на изображении main axis - главная ось по которой располагаются дочерние объекты. Кстати, совсем не обязательно это должна быть горизонтальная ось, это завсист от указанного вами flex-direction свойства (см.ниже). main-start | main-end - дочерние блоки располагаются от main-start и до main-end. Фактически начало и конец оси. main size - длина или ширина доступная для заполнения дочерними элементами вдоль главной оси. cross axis - ось, перпендикулярная главной оси. Направление перпендикулярной оси зависит от того, какую ось вы указали в качестве главной. cross-start | cross-end - начало и конец перпендикулярной оси, по которой будут располагаться дочерние элементы. cross size- длина или ширина доступная для заполнения дочерними элементами вдоль перпендикулярной оси. В итоге нас есть Родительский элемент (flex container), в котором расположены дочерние элементы (flex item) и набор правил для управления выводом этих элементов. Давайте последовательно разберем эти свойства. Свойства родительского элемента (flex container) display Это свойство определяет родительский контейнер, так же оно активирует контекст для всех дочерних элементов flex-direction Это свойство определяет главную ось и направление расположения блоков вдоль нее. В общих чертах flexbox располагает блоки либо по горизонтали (row) либо по вертикали (column) вдоль оси. row - (по умолчанию) слева на право (ltr) либо справа на лево (rtl); row-reverse - меняет порядок на противоположный; column - тоже самое что и row но для направления сверху в низ; column-reverse - меняет направление для вертикальной оси. flex-wrap Это свойство определяет порядок переноса элементов. По умолчанию все дочерние элементы стремятся уместиться на одной линии по направлению главной оси. nowrap - (используется по умолчанию) расположение блоков в одну строку; wrap - расположение в несколько линий (похоже на перенос по словам в письменной речи); wrap-reverse - расположение в несколько линий только в обратном направлении главной оси. flex-flow Это свойство является сокращением для комбинирования 2х свойств: flex-direction и flex-wrap. Оба этих свойства вместе определяют главную и перпендикулярную ось. По умолчанию используются значения row и nowrap соответсвенно. justify-content Это свойство определяет расположение блоков вдоль главной оси. Это свойство помогает распределить свободное место оставшееся после рендеринга дочерних элементов. Так же это дает некоторою возможность для разработчика управлять поведением элементов при переполнении родительского контейнера. flex-start - (по умолчанию) дочерние элементы группируются у стартовой лини (main-start на общей схеме) вдоль главной оси; flex-end - дочерние элементы группируются у конечной линии (main-end на общей схеме) вдоль главной оси; center - дочерние элементы центрированы по центру главной оси; space-between - первый элемент на стартовой лини (main-start на общей схеме), последний на конечной линии(main-end на общей схеме), а свободное пространство распределяется равномерно между оставшимися элементами; space-around - распределяет свободное место для всех дочерних элементов равномерно, но с учетом индивидуальных свойств отступов для дочерних элементов. align-items Это свойство определяет расположение дочерних элементов (flex items) относительно друг друга по перпендикулярной оси. Можно сказать что это свойство такое же как justify-content только для перпендикулярной оси. Чем то напоминает мне свойство vertical-align для inline-block элементов. flex-start - начальная граница перпендикулярной оси (cross-start на общей схеме); flex-end - конечная граница перпендикулярной оси (cross-end на общей схеме); center - дочерние объекты располагаются относительно центра перпендикулярной оси; baseline - элементы располагаются по базовой линии относительно друг друга; stretch - (по умолчанию) элементы вытягиваются вдоль перпендикулярной оси и занимают все пространство родительского блока. align-content Это свойство выравнивает линии внутри родительского контейнера вдоль перпендикулярной оси (cross-axis на общей схеме), аналогично тому как работает свойство justify-content только не для отдельного элемента а для всей строки (линии) элементов сразу. Это свойство не работает если элементы не переносятся на другую строку. flex-start - линии группируются у стартовой позиции перпендикулярной оси контейнера; flex-end - линии группируются у конечной позиции перпендикулярной оси; center - линии группируются по центру перпендикулярной оси; space-between - Первая линия элементов располагается у стартовой позиции оси а последняя у конечной. Линии между первой и последней распределяются равномерно между собой вдоль перпендикулярной оси; space-around - линии равномерно распределены относительно друг друга вдоль перпендикулярной оси с равным расстоянием между друг другом; stretch - линии равномерно расширяются чтобы занять все свободное пространство относительно перпендикулярной оси. Свойства дочерних объектов (flex items) order По умолчанию дочерние объекты расположены в поредяке следования по исходному коду. Это свойство позволяет контролировать порядок отображение объектов относительно друг друга. flex-grow Это свойство определяет способность отдельных элементов расширятся при необходимости. Свойство является по сути пропорцией относительно других элементов. Если всем элементам задать значение 1 для этого свойства, каждый элемент будет одинаковой ширины, если же одному из этих элементов задать 2, то этот элемент будет в 2 раза шире остальных. flex-shrink Это свойство определяет способность элемента к расширению, так же является пропорцией к остальным элементам. По умолчанию равно 1. flex-basis Это свойство определяет размер элемента по умолчанию, перед тем как произойдет распределение свободного пространства между остальными элементами. Если указано свойство main-size то тогда flex-basis будет равно css свойствам height или width этого элемнта, в зависимости от того какая ось и направление активны. flex Это свойство является комбинированным сокращением для свойств: flex-grow, flex-shrink и flex-basis. Второй и третий параметр ( flex-shrink и flex-basis) не обязательны. Значение этого свойства по умолчанию: 0 1 auto Рекомендуется использовать именно это свойство вместо использования отдельных flex-grow, flex-shrink и flex-basis. align-self Это свойство позволяет индивидуально выравнивать конкретный выбранный элемент относительно других. Имеет приоритет над общим свойством align-items. Вот собственно и все. Данная заметка является моим вольным переводом оригинальной статьи Криса Койера, Там вы можете уточнить информацию а так же найти примеры использования, таблицу поддержки flexbox в различных браузерах и т.д." />
<link rel="canonical" href="https://handleman.github.io/translation/2015/09/05/podrobnoe-rukovodstvo-po-flexbox.html" />
<meta property="og:url" content="https://handleman.github.io/translation/2015/09/05/podrobnoe-rukovodstvo-po-flexbox.html" />
<meta property="og:site_name" content="Переводы, комиксы, разработка" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2015-09-05T13:35:59+03:00" />
<script type="application/ld+json">
{"description":"Простыми словами, flexbox layout (флексбокс) это набор CSS правил описывающий принцип, который помогает разработчику удобно располагать блоки относительно друг друга и эффективнее использовать свободное место между блоками на странице. Использование flexbox решает старую наболевшую проблему — центрирование блоков по вертикали при неизвестной высоте как самих блоков, так и подложки под ними. Основная идея, стоящая за flexbox, это: способность родительского контейнера менять высоту/ширину (и порядок) своих дочерних элементов, для наиболее эффективного использования доступного пространства (также для того, чтобы подстраиваться под разрешение всех видов устройств и размеров экранов). Короче говоря, родительский флекс-контейнер расширяет внутренние блоки чтобы занять свободное пространство или же сжимает их чтобы избежать наложения их друг на друга. Самое важное во flexbox, это то, что этот принцип не зависит от общего направления отрисовки страницы и других блоков (display: block, которые следуют друг за другом вертикально и display: inline, которые располагаются горизонтально друг от друга). Старый принцип (block,inline,inline-block) работает отлично, но для простых страниц. Современные сложные динамические интерфейсы требуют более эффективный подход. Терминология Потому как flexbox Это отдельный принцип расположения блоков, а не просто CSS свойство, помимо прочего, он включает в себя целый набор свойств. Некоторые из этих свойств предназначены для применения на родительском контейнере (flex container) тогда как другие — на дочерних (flex items). Если обычный метод верстки строится на порядке следования отрисовки страницы, flex использует свой принцип для выстраивания порядка следования дочернихблоков (flex-flow directions). Предлагаю взглянуть на изображение из спецификации и разобрать все термины по порядку. Общая схема flexbox layout В общих чертах, можно сказать, что блоки внутри родительского контейнера будут располагаться по главной оси (main axis) от начала (main-start) до конца оси (main-end) или же по перпендикулярной оси (cross axis) от начала (cross-start) до конца оси (cross-end). Термины на изображении main axis - главная ось по которой располагаются дочерние объекты. Кстати, совсем не обязательно это должна быть горизонтальная ось, это завсист от указанного вами flex-direction свойства (см.ниже). main-start | main-end - дочерние блоки располагаются от main-start и до main-end. Фактически начало и конец оси. main size - длина или ширина доступная для заполнения дочерними элементами вдоль главной оси. cross axis - ось, перпендикулярная главной оси. Направление перпендикулярной оси зависит от того, какую ось вы указали в качестве главной. cross-start | cross-end - начало и конец перпендикулярной оси, по которой будут располагаться дочерние элементы. cross size- длина или ширина доступная для заполнения дочерними элементами вдоль перпендикулярной оси. В итоге нас есть Родительский элемент (flex container), в котором расположены дочерние элементы (flex item) и набор правил для управления выводом этих элементов. Давайте последовательно разберем эти свойства. Свойства родительского элемента (flex container) display Это свойство определяет родительский контейнер, так же оно активирует контекст для всех дочерних элементов flex-direction Это свойство определяет главную ось и направление расположения блоков вдоль нее. В общих чертах flexbox располагает блоки либо по горизонтали (row) либо по вертикали (column) вдоль оси. row - (по умолчанию) слева на право (ltr) либо справа на лево (rtl); row-reverse - меняет порядок на противоположный; column - тоже самое что и row но для направления сверху в низ; column-reverse - меняет направление для вертикальной оси. flex-wrap Это свойство определяет порядок переноса элементов. По умолчанию все дочерние элементы стремятся уместиться на одной линии по направлению главной оси. nowrap - (используется по умолчанию) расположение блоков в одну строку; wrap - расположение в несколько линий (похоже на перенос по словам в письменной речи); wrap-reverse - расположение в несколько линий только в обратном направлении главной оси. flex-flow Это свойство является сокращением для комбинирования 2х свойств: flex-direction и flex-wrap. Оба этих свойства вместе определяют главную и перпендикулярную ось. По умолчанию используются значения row и nowrap соответсвенно. justify-content Это свойство определяет расположение блоков вдоль главной оси. Это свойство помогает распределить свободное место оставшееся после рендеринга дочерних элементов. Так же это дает некоторою возможность для разработчика управлять поведением элементов при переполнении родительского контейнера. flex-start - (по умолчанию) дочерние элементы группируются у стартовой лини (main-start на общей схеме) вдоль главной оси; flex-end - дочерние элементы группируются у конечной линии (main-end на общей схеме) вдоль главной оси; center - дочерние элементы центрированы по центру главной оси; space-between - первый элемент на стартовой лини (main-start на общей схеме), последний на конечной линии(main-end на общей схеме), а свободное пространство распределяется равномерно между оставшимися элементами; space-around - распределяет свободное место для всех дочерних элементов равномерно, но с учетом индивидуальных свойств отступов для дочерних элементов. align-items Это свойство определяет расположение дочерних элементов (flex items) относительно друг друга по перпендикулярной оси. Можно сказать что это свойство такое же как justify-content только для перпендикулярной оси. Чем то напоминает мне свойство vertical-align для inline-block элементов. flex-start - начальная граница перпендикулярной оси (cross-start на общей схеме); flex-end - конечная граница перпендикулярной оси (cross-end на общей схеме); center - дочерние объекты располагаются относительно центра перпендикулярной оси; baseline - элементы располагаются по базовой линии относительно друг друга; stretch - (по умолчанию) элементы вытягиваются вдоль перпендикулярной оси и занимают все пространство родительского блока. align-content Это свойство выравнивает линии внутри родительского контейнера вдоль перпендикулярной оси (cross-axis на общей схеме), аналогично тому как работает свойство justify-content только не для отдельного элемента а для всей строки (линии) элементов сразу. Это свойство не работает если элементы не переносятся на другую строку. flex-start - линии группируются у стартовой позиции перпендикулярной оси контейнера; flex-end - линии группируются у конечной позиции перпендикулярной оси; center - линии группируются по центру перпендикулярной оси; space-between - Первая линия элементов располагается у стартовой позиции оси а последняя у конечной. Линии между первой и последней распределяются равномерно между собой вдоль перпендикулярной оси; space-around - линии равномерно распределены относительно друг друга вдоль перпендикулярной оси с равным расстоянием между друг другом; stretch - линии равномерно расширяются чтобы занять все свободное пространство относительно перпендикулярной оси. Свойства дочерних объектов (flex items) order По умолчанию дочерние объекты расположены в поредяке следования по исходному коду. Это свойство позволяет контролировать порядок отображение объектов относительно друг друга. flex-grow Это свойство определяет способность отдельных элементов расширятся при необходимости. Свойство является по сути пропорцией относительно других элементов. Если всем элементам задать значение 1 для этого свойства, каждый элемент будет одинаковой ширины, если же одному из этих элементов задать 2, то этот элемент будет в 2 раза шире остальных. flex-shrink Это свойство определяет способность элемента к расширению, так же является пропорцией к остальным элементам. По умолчанию равно 1. flex-basis Это свойство определяет размер элемента по умолчанию, перед тем как произойдет распределение свободного пространства между остальными элементами. Если указано свойство main-size то тогда flex-basis будет равно css свойствам height или width этого элемнта, в зависимости от того какая ось и направление активны. flex Это свойство является комбинированным сокращением для свойств: flex-grow, flex-shrink и flex-basis. Второй и третий параметр ( flex-shrink и flex-basis) не обязательны. Значение этого свойства по умолчанию: 0 1 auto Рекомендуется использовать именно это свойство вместо использования отдельных flex-grow, flex-shrink и flex-basis. align-self Это свойство позволяет индивидуально выравнивать конкретный выбранный элемент относительно других. Имеет приоритет над общим свойством align-items. Вот собственно и все. Данная заметка является моим вольным переводом оригинальной статьи Криса Койера, Там вы можете уточнить информацию а так же найти примеры использования, таблицу поддержки flexbox в различных браузерах и т.д.","@type":"BlogPosting","url":"https://handleman.github.io/translation/2015/09/05/podrobnoe-rukovodstvo-po-flexbox.html","headline":"Перевод: Подробное руководство по flexbox","dateModified":"2015-09-05T13:35:59+03:00","datePublished":"2015-09-05T13:35:59+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://handleman.github.io/translation/2015/09/05/podrobnoe-rukovodstvo-po-flexbox.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->

    <meta name="description" content="Мой личный блог, связанный с веб-разработкой. Где я публикую переводы понравившихся мне тематических статей, делюсь впечатлениями о прочитанных мною комиксах, и делюсь своим опытом.">
    <link rel="shortcut icon" href="/assets/favicon.ico" />
    <link rel="stylesheet" href="/assets/css/bootstrap.css"/>
    <link rel="stylesheet" href="/assets/css/styles.css"/>
</head>

<body>
<section  role="main" class="container">
    <div class="row mobile-header hidden-md hidden-lg">
        <nav class="navbar navbar-default" role="navigation">

            <div class="navbar-header">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#collapsed-navbar">
                    <span class="sr-only">Навигация</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="#">Блог.</a>
            </div>

            <div class="collapse navbar-collapse" id="collapsed-navbar">
                <ul class="nav navbar-nav">
                    <li class="active"><a href="/"><span class="glyphicon glyphicon-home"></span>Главная</a></li>
                    <li><a href="/about.html"><span class="glyphicon glyphicon-envelope"></span>Контакты</a></li>
                    <!--<li><a href="http://cv.handleman.ru/" ><span class="glyphicon glyphicon-briefcase"></span>CV и портфолио</a></li>-->
                    <!--<li><a href="#" ><span class="glyphicon glyphicon-bookmark"></span>RSS блога</a></li>-->
                </ul>
            </div><!-- /.navbar-collapse -->
        </nav>
    </div>
    <div class="row">

        <div class="col-xs-12 col-sm-12 col-lg-8 col-md-8 text-body">
            <header role="banner" class="main-header hidden-sm hidden-xs"></header>
            <section role="main" class="content">
                <article>
    <h1>Перевод: Подробное руководство по flexbox</h1>
    <div class="addthis_inline_share_toolbox"></div>
    <p>Простыми словами, flexbox layout (флексбокс) это набор CSS правил описывающий принцип, который помогает разработчику удобно располагать блоки относительно друг друга и эффективнее использовать свободное место между блоками на странице.</p>
<p>Использование flexbox решает старую наболевшую проблему — центрирование блоков по вертикали при неизвестной высоте как самих блоков, так и подложки под ними.</p>
<p>Основная идея, стоящая за flexbox, это: способность родительского контейнера менять высоту/ширину (и порядок) своих дочерних элементов, для наиболее эффективного использования доступного пространства (также для того, чтобы подстраиваться под разрешение всех видов устройств и размеров экранов). Короче говоря, родительский флекс-контейнер расширяет внутренние блоки чтобы занять свободное пространство или же сжимает их чтобы избежать наложения их друг на друга.</p>
<p>Самое важное во flexbox, это то, что этот принцип не зависит от общего направления отрисовки страницы и других блоков (display: block, которые следуют друг за другом вертикально и display: inline, которые располагаются горизонтально друг от друга). Старый принцип (block,inline,inline-block) работает отлично, но для простых страниц. Современные сложные динамические интерфейсы требуют более эффективный подход.</p>
<h2>Терминология</h2>
<p>Потому как flexbox Это отдельный принцип расположения блоков, а не просто CSS свойство, помимо прочего, он включает в себя целый набор свойств. Некоторые из этих свойств предназначены для применения на родительском контейнере (flex container) тогда как другие — на дочерних (flex items).</p>
<p>Если обычный метод верстки строится на порядке следования отрисовки страницы, flex использует свой принцип для выстраивания порядка следования дочернихблоков (flex-flow directions).</p>
<p><strong>Предлагаю взглянуть на изображение из спецификации и разобрать все термины по порядку.</strong></p>
<h2>Общая схема flexbox layout</h2>
<p><img style="margin-left: auto; margin-right: auto;" src="/assets/images/articles/flexbox/flexbox.png" alt="Общая схема flexbox layout." /></p>
<p>В общих чертах, можно сказать, что блоки внутри родительского контейнера будут располагаться по главной оси (main axis) от начала (main-start) до конца оси (main-end) или же по перпендикулярной оси (cross axis) от начала (cross-start) до конца оси (cross-end).</p>
<h3>Термины на изображении</h3>
<ul>
<li><strong>main axis</strong> - главная ось по которой располагаются дочерние объекты. Кстати, совсем не обязательно это должна быть горизонтальная ось, это завсист от указанного вами flex-direction свойства (см.ниже).</li>
<li><strong>main-start | main-end </strong> - дочерние блоки располагаются от main-start и до main-end. Фактически начало и конец оси.</li>
<li><strong>main size</strong> - длина или ширина доступная для заполнения дочерними элементами вдоль главной оси.</li>
<li><strong>cross axis</strong> - ось, перпендикулярная главной оси. Направление перпендикулярной оси зависит от того, какую ось вы указали в качестве главной.</li>
<li><strong>cross-start | cross-end</strong> - начало и конец перпендикулярной оси, по которой будут располагаться дочерние элементы.</li>
<li><strong>cross size</strong>- длина или ширина доступная для заполнения дочерними элементами вдоль перпендикулярной оси.</li>
</ul>
<p>В итоге нас есть Родительский элемент (flex container), в котором расположены дочерние элементы (flex item) и набор правил для управления выводом этих элементов. Давайте последовательно разберем эти свойства.</p>
<h2>Свойства родительского элемента (flex container)</h2>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/flex-container.png" alt="flex container" /></p>
<h3>display</h3>
<p>Это свойство определяет родительский контейнер, так же оно активирует контекст для всех дочерних элементов</p>
<script type="text/javascript" src="https://gist.github.com/handleman/f453cd276e14126da57e.js"></script>

<h3>flex-direction</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/flex-direction1.png" alt="flex container" /></p>
<p>Это свойство определяет главную ось и направление расположения блоков вдоль нее. В общих чертах flexbox располагает блоки либо по горизонтали (row) либо по вертикали (column) вдоль оси.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/2d55e19fc0c9e8eb2d6e.js"></script>

<ul>
<li><strong>row - (по умолчанию)</strong> слева на право (ltr) либо справа на лево (rtl);</li>
<li><strong>row-reverse</strong> - меняет порядок на противоположный;</li>
<li><strong>column</strong> - тоже самое что и row но для направления сверху в низ;</li>
<li><strong>column-reverse</strong> - меняет направление для вертикальной оси.</li>
</ul>
<h3>flex-wrap</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/flex-wrap.png" alt="flex container" /></p>
<p>Это свойство определяет порядок переноса элементов. По умолчанию все дочерние элементы стремятся уместиться на одной линии по направлению главной оси.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/9805af0c0c85213d9789.js"></script>

<ul>
<li><strong>nowrap </strong>- (используется по умолчанию) расположение блоков в одну строку;</li>
<li><strong>wrap </strong>- расположение в несколько линий (похоже на перенос по словам в письменной речи);</li>
<li><strong>wrap-reverse</strong> - расположение в несколько линий только в обратном направлении главной оси.</li>
</ul>
<h3>flex-flow</h3>
<p>Это свойство является сокращением для комбинирования 2х свойств: flex-direction и flex-wrap. Оба этих свойства вместе определяют главную и перпендикулярную ось. По умолчанию используются значения row и nowrap соответсвенно.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/270d1b50730c4204054a.js"></script>

<h3>justify-content</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/justify-content.png" alt="flex container" /></p>
<p>Это свойство определяет расположение блоков вдоль главной оси. Это свойство помогает распределить свободное место оставшееся после рендеринга дочерних элементов. Так же это дает некоторою возможность для разработчика управлять поведением элементов при переполнении родительского контейнера.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/1c3af7d75d2b68c82a45.js"></script>

<ul>
<li><strong>flex-start - (по умолчанию)</strong> дочерние элементы группируются у стартовой лини (main-start на общей схеме) вдоль главной оси;</li>
<li><strong>flex-end</strong> - дочерние элементы группируются у конечной линии (main-end на общей схеме) вдоль главной оси;</li>
<li><strong>center </strong>- дочерние элементы центрированы по центру главной оси;</li>
<li><strong>space-between</strong> - первый элемент на стартовой лини (main-start на общей схеме), последний на конечной линии(main-end на общей схеме), а свободное пространство распределяется равномерно между оставшимися элементами;</li>
<li><strong>space-around </strong>- распределяет свободное место для всех дочерних элементов равномерно, но с учетом индивидуальных свойств отступов для дочерних элементов.</li>
</ul>
<h3>align-items</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/align-items.png" alt="flex container" /></p>
<p>Это свойство определяет расположение дочерних элементов (flex items) относительно друг друга по перпендикулярной оси. Можно сказать что это свойство такое же как justify-content только для перпендикулярной оси. Чем то напоминает мне свойство vertical-align для inline-block элементов.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/d2e167834e211b29ecfe.js"></script>

<ul>
<li><strong>flex-start</strong> - начальная граница перпендикулярной оси (cross-start на общей схеме);</li>
<li><strong>flex-end</strong> - конечная граница перпендикулярной оси (cross-end на общей схеме);</li>
<li><strong>center </strong>- дочерние объекты располагаются относительно центра перпендикулярной оси;</li>
<li><strong>baseline</strong> - элементы располагаются по базовой линии относительно друг друга;</li>
<li><strong>stretch</strong> - (по умолчанию) элементы вытягиваются вдоль перпендикулярной оси и занимают все пространство родительского блока.</li>
</ul>
<h3>align-content</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/align-content.png" alt="flex container" /></p>
<p>Это свойство выравнивает линии внутри родительского контейнера вдоль перпендикулярной оси (cross-axis на общей схеме), аналогично тому как работает свойство justify-content только не для отдельного элемента а для всей строки (линии) элементов сразу.</p>
<p>Это свойство не работает если элементы не переносятся на другую строку.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/c21fd9007cd8ba306e95.js"></script>

<ul>
<li><strong>flex-start </strong>- линии группируются у стартовой позиции перпендикулярной оси контейнера;</li>
<li><strong>flex-end</strong> - линии группируются у конечной позиции перпендикулярной оси;</li>
<li><strong>center</strong> - линии группируются по центру перпендикулярной оси;</li>
<li><strong>space-between</strong> - Первая линия элементов располагается у стартовой позиции оси а последняя у конечной. Линии между первой и последней распределяются равномерно между собой вдоль перпендикулярной оси;</li>
<li><strong>space-around</strong> - линии равномерно распределены относительно друг друга вдоль перпендикулярной оси с равным расстоянием между друг другом;</li>
<li><strong>stretch</strong> - линии равномерно расширяются чтобы занять все свободное пространство относительно перпендикулярной оси.</li>
</ul>
<h2>Свойства дочерних объектов (flex items)</h2>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/flex-items.png" alt="flex container" /></p>
<h3>order</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/order-2.png" alt="flex container" /></p>
<p>По умолчанию дочерние объекты расположены в поредяке следования по исходному коду. Это свойство позволяет контролировать порядок отображение объектов относительно друг друга.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/2d51ef66a431361b17b2.js"></script>

<h3>flex-grow</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/flex-grow.png" alt="flex container" /></p>
<p>Это свойство определяет способность отдельных элементов расширятся при необходимости. Свойство является по сути пропорцией относительно других элементов.</p>
<p>Если всем элементам задать значение 1 для этого свойства, каждый элемент будет одинаковой ширины, если же одному из этих элементов задать 2, то этот элемент будет в 2 раза шире остальных.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/570b361b19997c6d16ab.js"></script>

<h3>flex-shrink</h3>
<p>Это свойство определяет способность элемента к расширению, так же является пропорцией к остальным элементам. По умолчанию равно 1.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/723a0fd8cdd981a5cbb6.js"></script>

<h3>flex-basis</h3>
<p>Это свойство определяет размер элемента по умолчанию, перед тем как произойдет распределение свободного пространства между остальными элементами. Если указано свойство main-size то тогда flex-basis будет равно css свойствам height или width этого элемнта, в зависимости от того какая ось и направление активны.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/c749a81ea3a2ceba8f77.js"></script>

<h3>flex</h3>
<p>Это свойство является комбинированным сокращением для свойств: flex-grow, flex-shrink и flex-basis. Второй и третий параметр ( flex-shrink и flex-basis) не обязательны. Значение этого свойства по умолчанию: 0 1 auto</p>
<script type="text/javascript" src="https://gist.github.com/handleman/b406879ce91dfc1529e4.js"></script>

<p>Рекомендуется использовать именно это свойство вместо использования отдельных flex-grow, flex-shrink и flex-basis.</p>
<h3>align-self</h3>
<p><img class="adaptive-image" src="/assets/images/articles/flexbox/align-self.png" alt="flex container" /></p>
<p>Это свойство позволяет индивидуально выравнивать конкретный выбранный элемент относительно других. Имеет приоритет над общим свойством align-items.</p>
<script type="text/javascript" src="https://gist.github.com/handleman/6f3d1dd47ea57277d2d4.js"></script>

<p>Вот собственно и все.</p>
<p>Данная заметка является моим вольным переводом <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">оригинальной статьи Криса Койера</a>, Там вы можете уточнить информацию а так же найти примеры использования, таблицу поддержки flexbox в различных браузерах и т.д.</p>

    <section class="post-info text-muted"><small>Опубликовано <strong>05 Sep 2015</strong> </small></section>
</article>
<hr />
<section class="post-comments" id="comments">
    <h2>комментарии:</h2>
    <!-- Nav tabs -->
    <div >
        <div class="  simple-comments " id="simple-comments">
            <div id="disqus_thread"></div>
            <script type="text/javascript">
				/* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
				var disqus_shortname = 'handleman'; // required: replace example with your forum shortname

				/* * * DON'T EDIT BELOW THIS LINE * * */
				(function() {
					var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
					dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
					(document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
				})();
            </script>
            <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
        </div>
    </div>
</section>


            </section>
        </div>
        <aside class="col-md-4 col-lg-4 hidden-sm hidden-xs left-side">
    <a href="/" class="logo animated">В индекс</a>
    <p style="color:#f5f5f5; text-align:center; margin-bottom:1em;">Переводы, комиксы, разработка...</p>
    <div class="panel panel-primary">
        <!--<div class="panel-heading">Навигация</div>-->
<nav role="navigation">
    <div class="list-group nav">
        <div>
            
            <a href="/about" class="list-group-item ">
                Контакты
            </a>
            
        </div>
    </div>
</nav>

    </div>

    <div class="panel panel-primary">
        <div class="panel-heading">Мой твиттер</div>
        <a class="twitter-timeline" data-tweet-limit="3" href="https://twitter.com/PHandleman" data-widget-id="536070279681040384">Твиты от @PHandleman</a>
        <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+"://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>

    </div>
</aside>
    </div>
    <div class="row footer-row">
        <footer role="contentinfo" class="col-md-9 col-lg-9 ">
            <nav>
                <a href="/">На главную</a>
                <a href="/about.html">Контакты</a>
            </nav>
            <a href="#" title="В начало страницы" class="to-top-btn"><span class="glyphicon glyphicon-circle-arrow-up">&nbsp;</span></a>
        </footer>

    </div>
</section>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script src="/assets/js/jquery.scrollTo.min.js"></script>
<script src="/assets/js/page.js"></script>
<script type="text/javascript" src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5304a714568001ec"></script>
</body>
</html>